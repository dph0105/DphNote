使用Glide我们一般是三步骤，Glide.with().load().into()

Glide.with()方法返回了一个RequestManager对象，根据我们传入的context，如果是Application的，那么会创建Application级别的RequestManager，它无法管理图片加载或者取消

如果传入的context是Activity、Fragment、View，则会根据Android版本调用fragmentGet方法或者supportFragmentGet方法。

这两个方法类似，都是获得一个Fragment实例，区别在于一个是app包下，一个是v4包下。

这两个方法会创建或者服用一个RequestManagerFragment，它是一个无视图的Fragment，每个RequestManagerFragment会持有一个RequestManager，通过这个RequestManager控制当前页面的Glide的图片的加载。RequestManager实现了LifecycleListener接口，RequestManagerFragment的生命周期方法中会回调这些方法来控制Glide的一个加载

然后是load方法，这里的load方法是RequestManager调用的，它返回一个RequestBuilder<Drawable>对象，RequestBuilder需要指定一个泛型，load方法中默认的是<Drawable> 

然后是into方法，这里会创建真正的请求Request，并且最终调用它的begin方法，这里会判断是否取到了target的宽高，如果取到了，就调用onSizeReady，如果没取到，就调用target的getSize方法获取宽高，最终还是会调用onSizeReady方法。

这个方法中会调用Engine类的load方法，首先根据一些参数（包含id，签名，图片宽高等信息）构建一个EngineKey用作缓存的Key，根据这个Key，先从弱引用缓存当中资源，如果没有，则从内存缓存中获取资源。

如果没有内存缓存，那么会创建EngineJob和DecodeJob，然后调用EngineJob的start方法，通过GlideExecutor在子线程中执行DecodeJob的run方法。

这里首先会寻找磁盘缓存，如果没有，那么最终会通过HttpUrlFetcher的loadData方法获取图片的数据流，loadData方法是使用Android自带的HttpURLConnection执行请求，得到一个InputStream。

获得InputStream之后，通过回调又会重新来到DecodeJob的run方法中，这次执行的是缓存

然后解码将图片转化为RequestBuilder中设置的类型，然后通过EngineJob的onResourceReady回调，通过Handler将消息发送到主线程，然后又通过Request的onResourceReady回调，调用target的onResourceReady，这里的target是Glide为我们创建的ImageViewTarget，直接通过ImageView的setImageDrawable方法设置图片

