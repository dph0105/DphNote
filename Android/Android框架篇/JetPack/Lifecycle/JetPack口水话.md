#### Lifecycle-Aware

Lifecycle-Aware组件有三大角色，LifecycleOwner，Lifecycle，LifecycleObserver。LifecycleOwner是一个接口，实现这个接口表示该类具有Android生命周期，它需要实现getLifecycle()方法，返回一个Lifecycle对象。Lifecycle是一个抽象类，LifecycleRegistry继承了Lifecycle，它维护生命周期状态，以及管理LifecycleObserver。LifecycleObserver也是一个接口，它表示Android生命周期的观察者。

LifecycleRegistry通过addObserver添加Observer，这个方法会创建一个ObserverWithState对象，并将这个对象加入到map中维护起来。ObserverWithState的构造器需要传入我们创建的LifecycleObserver，并得到一个LifecycleEventObserver对象。

LifecycleEventObserver则是事件的真正的接收者，它实现了LifecyleObserver。在ObserverWithState的构造器中，会传入我们创建的LifecycleObserver，如果我们传入的不是LifecycleEventObserver，那么会通过反射解析我们创建的LifecycleObserver的那些注解方法，创建一个LifecycleEventObserver。

当有生命周期事件时，就会遍历LifecycleRegistry中的ObserverWithState，调用它的dispatchEvent方法，这个方法里又会调用LifecycleEventObserver的onStateChanged方法。

ComponentActivity实现了LifecycleOwner，并且创建了LifecycleRegistry对象。在它的onCreate方法中，它会创建一个ReportFragment，这是一个无视图的Fragment，在这个Fragment的生命周期事件中，它会分发事件。

#### ViewModel

在ComponentActivity的构造方法中，会向它的LifecycleRegistry中添加Observer，当生命周期为OnDestroy时，调用ViewModelStore的clear方法，这个方法会调用Store中的ViewModel的clear方法。ViewModelStore用来存放ViewModel

#### LiveData

执行LiveData的observe的时候需要传入一个LifecycleOwner和一个Observer

Observer会被包装成一个LifecycleBoundObserver，它是一个LifecycleEventObserver，它会被添加到LifecycleOwner的LifecycleRegistry当中。当生命周期为DESTROYED的时候，就会调用LiveData的removeObserver方法移除所有LiveData的观察者。

然后会将Observer加入到LiveData的一个Map中。

当调用LiveData的setValue方法时，会判断是否在主线程，然后会增加LiveData的版本号，然后遍历LiveData的Observer Map，调用considerNotify方法。

LifecycleBoundObserver有个mLastVersion参数，记录这最后一次更新时的LiveData中的Version值，当Observer中的mLastVersion大于等于LiveData当前的Version值时，不更新。否则，会调用我们实现的Observer的onChanged方法，并更新mLastVersion的值。

LiveData的postValue方法则允许在子线程中更新数据，LiveData中有一个mPendingData，表示等待设置的数据，它被volatile修饰，当它 == NOT_SET时，即会被设置为要设置的值，也会切换到主线程如果不等于NOT_SET，那么只会重新被赋值

来到主线程中，会取出mPendingData的值，然后设置mPendingData为NOT_SET,然后调用setValue方法。

mPendingData的读写操作都设置了synchronized，保证了多次调用postValue，只有最后一次才会被更新。



