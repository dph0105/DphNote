调用startActivity方法，最终会执行Instrumentation的execStartActivity方法。

这个方法会通过Binder远程调用ActivityTaskManagerService的startActivity方法，这个方法会传递三个重要的参数，ApplicationThread，mToken，Intent。ApplicationThread是一个Binder本地对象，ATMS可以通过它来通知上一个Activity进入Pause状态。mToken是一个Binder对象代理，它指向ATMS中的一个ActivityRecord的Binder本地对象，每一个Activity在ATMS中都有一个对应的ActivityRecord对象，用来维护对应的Activity组件的运行状态及信息。

ATMS会通过ActivityStartController创建或者复用一个ActivityStarter并执行它的execute方法

这个方法会创建要启动的Activity的ActivityRecord，并且会设置它的ActivityStack，然后最终会执行到ActivityStack的resumeTopActivityInnerLocked，这个方法有两个功能，一个是通知上一个Activity暂停，另一个是启动新的Activity。当第一次进入时，是通知上一个Activity进入暂停状态。

这时会进入startPausingLocked方法，它会通过上一个Activity的ActivityRecord中的ApplicationThread的Binder代理对象，向app进程（如果是开启app的话，就是Launcher进程）发送ClientTransaction事务，最终会通过ActivityThread的Handler，执行handlePauseActivity。

app进程处理完暂停Activity的事务，会通知ATMS，重新进入该方法resumeTopActivityInnerLocked，这次是启动新的Activity

方法会接下去执行到ActivityStackSupervisor的startSpecificActivity方法

这个方法判断Activity所在进程是否存在，如果存在就直接执行realStartActivityLocked，如果不存在则调用ATMS的startProcessAsync方法，最终通过AMS的startProcessLocked创建进程

创建进程会设置entryPoint为ActivityThread，然后通过Socket通知Zygote进程fork新进程，新进程的入口就是ActivityThread的main函数，main函数中会创建消息循环，并调用attach方法。这个方法又会调用AMS的attachApplication，最终调用ATMS的LocalService的attachApplication方法，最终重新回到ActivityStackSupervisor的startSpecificActivity方法中。

然后ATMS开始启动新的Activity，与暂停一样，都是通过ApplicationThread，调用Handler执行ActivityThread的handleLaunchActivity

在handleLaunchActivity中，会通过Instrumentation的newActivity方法创建Activity，调用Activity的attach函数，这个函数里面会创建一个PhoneWindow，并关联WindowManager，最后调用Activity的onCreate方法

