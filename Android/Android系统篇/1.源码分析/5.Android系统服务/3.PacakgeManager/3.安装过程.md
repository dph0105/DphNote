# 一、背景

PackageManagerService（PMS） 是Android系统中重要的服务之一，类似 ActivityManagerService（AMS）的作用是负责Activity等四大组件的管理，PMS的作用是管理所有的APK。接下来我们通过APK的安装过程来研究PMS，代码基于Android 11

# 二、APK的安装过程

PackageInstaller 是Android提供的用于APK安装的系统应用，可以通过下面的代码来调起 PackageInstaller 安装APK：

```
Intent intent = new Intent(Intent.ACTION_VIEW);
intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
//Android8及以上，需要通过FileProvider去访问文件
Uri contentUri = FileProvider.getUriForFile(contex, context.getPackageName() +".file_provider", apkFile);
intent.setDataAndType(contentUri, "application/vnd.android.package-archive");
startActivity(intent);
```

上面的代码能调起安装界面，整个过程如图所示：

![](/imgs/PackageInstaller安装过程.png)

并且ActivityTaskManagerService（ATMS）的日志也输出了启动的页面信息：

```java
I/ActivityTaskManager: START u0 {act=android.intent.action.VIEW dat=content://com.dangbei.threadtransform.file_provider/download/Keep.apk typ=application/vnd.android.package-archive flg=0x10000001 cmp=com.google.android.packageinstaller/com.android.packageinstaller.InstallStart} from uid 10154
                                 
I/ActivityTaskManager: START u0 {act=android.intent.action.VIEW dat=content://com.dangbei.threadtransform.file_provider/download/Keep.apk typ=application/vnd.android.package-archive flg=0x2000000 cmp=com.google.android.packageinstaller/com.android.packageinstaller.InstallStaging (has extras)} from uid 10074                                

I/ActivityTaskManager: START u0 {act=android.intent.action.VIEW dat=file:///data/user_de/0/com.google.android.packageinstaller/no_backup/package554386892250049007.apk flg=0x2010000 cmp=com.google.android.packageinstaller/com.android.packageinstaller.DeleteStagedFileOnResult (has extras)} from uid 10074
                                 
dat=file:///data/user_de/0/com.google.android.packageinstaller/no_backup/package554386892250049007.apk flg=0x10000 cmp=com.google.android.packageinstaller/com.android.packageinstaller.PackageInstallerActivity (has extras)} from uid 10074
                                 
I/ActivityTaskManager: START u0 {act=android.settings.MANAGE_UNKNOWN_APP_SOURCES dat=package:com.dangbei.threadtransform cmp=com.android.settings/.Settings$ManageAppExternalSourcesActivity} from uid 10074
    
I/ActivityTaskManager: START u0 {dat=file:///data/user_de/0/com.google.android.packageinstaller/no_backup/package554386892250049007.apk flg=0x2000000 cmp=com.google.android.packageinstaller/com.android.packageinstaller.InstallInstalling (has extras)} from uid 10074
                                 
I/ActivityTaskManager: START u0 {dat=file:///data/user_de/0/com.google.android.packageinstaller/no_backup/package554386892250049007.apk flg=0x2000000 cmp=com.google.android.packageinstaller/com.android.packageinstaller.InstallSuccess (has extras)} from uid 10074
```

简单介绍一下这个过程：

1. InstallStart ，入口Activity
2. InstallStaging（对应图1） ，从 content URI 读取apk文件，复制到 PackageInstall 内部的目录中
3. DeleteStagedFileOnResult，用于安装成功或者失败之后，删除复制的临时apk文件，可以看到，打开该页面的apk参数已经改变了
4. PackageInstallerActivity（对应图2、3、4），未知来源安装的提示，展示 APK名称和图标并确认是否安装
5. InstallInstalling（对应图5）安装中
6. InstallSuccess（对应图6）安装完成，若安装失败则打开 InstallFail页面。

通过以上过程，我们来逐步了解 APK 是如何被安装的。

## 一、InstallStart

InstallStart 是 PackageInstaller 系统安装器的入口，可以在 \frameworks\base\packages\PackageInstaller\AndroidManifest.xml 中看到它的定义：

```xml
<activity android:name=".InstallStart"
        android:theme="@android:style/Theme.Translucent.NoTitleBar"
        android:exported="true"
        android:excludeFromRecents="true">
    <intent-filter android:priority="1">
        <action android:name="android.intent.action.VIEW" />
        <action android:name="android.intent.action.INSTALL_PACKAGE" />
        <category android:name="android.intent.category.DEFAULT" />
        <data android:scheme="content" />
        <data android:mimeType="application/vnd.android.package-archive" />
    </intent-filter>
    <--......-->
</activity>
```

除了上面定义的 IntentFilter 之外，还定义了两种其他的，由于不分析这里就不展示了。

既然是一个 Activity，就先看到它的 onCreate 方法中：

```java
public class InstallStart extends Activity {

    private static final String DOWNLOADS_AUTHORITY = "downloads";
    private PackageManager mPackageManager;
    private UserManager mUserManager;
    private boolean mAbortInstall = false;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
         mPackageManager = getPackageManager();
        mUserManager = getSystemService(UserManager.class);
        Intent intent = getIntent();
        //获取启动该Activity的调用方进程包名
        String callingPackage = getCallingPackage();
        String callingAttributionTag = null;
		//判断是否是 session安装，根据action是否为android.content.pm.action.CONFIRM_INSTALL来确定
        final boolean isSessionInstall =
                PackageInstaller.ACTION_CONFIRM_INSTALL.equals(intent.getAction());

       	//以session方式安装应用会有一个sessionId
        final int sessionId = (isSessionInstall
                ? intent.getIntExtra(PackageInstaller.EXTRA_SESSION_ID, -1)
                : -1);
        //callingPackage没有获取到的话，并且存在sessionId就通过session获取调用方的包名
        if (callingPackage == null && sessionId != -1) {
            PackageInstaller packageInstaller = getPackageManager().getPackageInstaller();
            PackageInstaller.SessionInfo sessionInfo = packageInstaller.getSessionInfo(sessionId);
            callingPackage = (sessionInfo != null) ? sessionInfo.getInstallerPackageName() : null;
            callingAttributionTag =
                    (sessionInfo != null) ? sessionInfo.getInstallerAttributionTag() : null;
        }
		//根据调用方的包名获取它的ApplicationInfo，判断它是否具有特殊权限 PRIVILEGED（特殊的）
        final ApplicationInfo sourceInfo = getSourceInfo(callingPackage);
        final int originatingUid = getOriginatingUid(sourceInfo);
        boolean isTrustedSource = false;
        if (sourceInfo != null
                && (sourceInfo.privateFlags & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) {
            //判断调起安装的进程是否可信任
            isTrustedSource = intent.getBooleanExtra(Intent.EXTRA_NOT_UNKNOWN_SOURCE, false);
        }
		//调起安装的进程是不信任的，则判断是否有安装权限
        if (!isTrustedSource && originatingUid != PackageInstaller.SessionParams.UID_UNKNOWN) {
            final int targetSdkVersion = getMaxTargetSdkVersionForUid(this, originatingUid);
            if (targetSdkVersion < 0) {//获取不到targetSdkVersion，则说明uid无效
                Log.w(LOG_TAG, "Cannot get target sdk version for uid " + originatingUid);
                mAbortInstall = true;
            } else if (targetSdkVersion >= Build.VERSION_CODES.O && !isUidRequestingPermission(
                    originatingUid, Manifest.permission.REQUEST_INSTALL_PACKAGES)) {
                //版本大于O时，需要申请 REQUEST_INSTALL_PACKAGES 权限
                Log.e(LOG_TAG, "Requesting uid " + originatingUid + " needs to declare permission "
                        + Manifest.permission.REQUEST_INSTALL_PACKAGES);
                mAbortInstall = true;
            }
        
        if (mAbortInstall) {//上面的情况发生时，取消安装 
            setResult(RESULT_CANCELED);
            finish();
            return;
        }
		//InstallStart只是一个入口，下面设置下一个跳转的Activity
        Intent nextActivity = new Intent(intent);
        nextActivity.setFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT
                | Intent.FLAG_GRANT_READ_URI_PERMISSION);

        //给nextActivity设置调用方的包名和uid
        nextActivity.putExtra(PackageInstallerActivity.EXTRA_CALLING_PACKAGE, callingPackage);
        nextActivity.putExtra(PackageInstallerActivity.EXTRA_CALLING_ATTRIBUTION_TAG,
                callingAttributionTag);
        nextActivity.putExtra(PackageInstallerActivity.EXTRA_ORIGINAL_SOURCE_INFO, sourceInfo);
        nextActivity.putExtra(Intent.EXTRA_ORIGINATING_UID, originatingUid);

        if (isSessionInstall) {
            //如果是session安装方式，则下一个Activity就是PackageInstallerActivity
            nextActivity.setClass(this, PackageInstallerActivity.class);
        } else {
            Uri packageUri = intent.getData();

            if (packageUri != null && packageUri.getScheme().equals(
                    ContentResolver.SCHEME_CONTENT)) {
               	//通过FileProvider提供的uri的scheme是content因此走这里跳转InstallStaging
                nextActivity.setClass(this, InstallStaging.class);
            } else if (packageUri != null && packageUri.getScheme().equals(
                    PackageInstallerActivity.SCHEME_PACKAGE)) {
                nextActivity.setClass(this, PackageInstallerActivity.class);
            } else {
                //其他情况则安装失败
                Intent result = new Intent();
                result.putExtra(Intent.EXTRA_INSTALL_RESULT,
                        PackageManager.INSTALL_FAILED_INVALID_URI);
                setResult(RESULT_FIRST_USER, result);
                nextActivity = null;
            }
        }

        if (nextActivity != null) {
            startActivity(nextActivity);
        }
        //InstallStart最后要被关闭
        finish();
    }
    
    //......
}
```

简单总结一下 InstallStart 做了什么：

1. 获取到调用安装的进程的包名
2. 判断是否是通过Session安装，若是则获取相关信息（Session会在后文解释）
3. 根据调用安装进程是否是可信任的，来判断是否需要 REQUEST_INSTALL_PACKAGES 权限，若没有权限则取消安装
4. 跳转下一个 Activity，若是Session安装或者 URI 的 Scheme 是 package 则跳转 PackageInstallerActivity，若URI 的 Scheme 是 content 则跳转 InstallStaging



## 二、InstallStaging

InstallStaging 的作用就是将调起安装方进程提供的APK文件复制到一个PackageInstall内部的暂存文件中，*stage file翻译为 暂存文件*

它的主要逻辑在 onResume中：

```java
public class InstallStaging extends AlertActivity {
    private static final String LOG_TAG = InstallStaging.class.getSimpleName();

    private static final String STAGED_FILE = "STAGED_FILE";

    private @Nullable StagingAsyncTask mStagingTask;

    private @Nullable File mStagedFile;

    @Override
    protected void onResume() {
        super.onResume();
        if (mStagingTask == null) {
            if (mStagedFile == null) {
                try {
                    mStagedFile = TemporaryFileManager.getStagedFile(this);
                } catch (IOException e) {
                    showError();
                    return;
                }
            }

            mStagingTask = new StagingAsyncTask();
            mStagingTask.execute(getIntent().getData());
        }
    }
    //......
}
```

在 onResume 中，若暂存文件 **mStagedFile** 是 null，就通过 `TemporaryFileManager.getStagedFile` 方法获得，文件名为 “ package ”  + （0 -Long.MaxValue 之间的随机数） + “ .apk ” ，目录在 /data/user_de/0/com.google.android.packageinstaller/no_backup/ 

若找不到该文件，可以在shell中通过find命令来找该文件： `find /data -name pacakge*.apk `

得到暂存文件 **mStagedFile** 之后就创建 **StagingAsyncTask** 对象，并开始执行复制任务。StagingAsyncTask 被定义在 InstallStaging 内部：

```java
	 private final class StagingAsyncTask extends AsyncTask<Uri, Void, Boolean> {
        @Override
        protected Boolean doInBackground(Uri... params) {
            //......
            try (InputStream in = getContentResolver().openInputStream(packageUri)) {
                if (in == null) {
                    return false;
                }
                try (OutputStream out = new FileOutputStream(mStagedFile)) {
                    byte[] buffer = new byte[1024 * 1024];
                    int bytesRead;
                    while ((bytesRead = in.read(buffer)) >= 0) {
                        if (isCancelled()) {
                            return false;
                        }
                        out.write(buffer, 0, bytesRead);
                    }
                }
            }//......
            return true;
        }

        @Override
        protected void onPostExecute(Boolean success) {
            if (success) {
                Intent installIntent = new Intent(getIntent());
                //复制apk到暂存文件后，启动DeleteStagedFileOnResult页面
                installIntent.setClass(InstallStaging.this, DeleteStagedFileOnResult.class);
                //这里将URI的scheme 协议从 content 改为了 file，因为mStagedFile的路径在内部
                installIntent.setData(Uri.fromFile(mStagedFile));
                if (installIntent.getBooleanExtra(Intent.EXTRA_RETURN_RESULT, false)) {
                    installIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);
                }
                installIntent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);
                startActivity(installIntent);
                InstallStaging.this.finish();
            } else {
                showError();
            }
        }
    }
```

InstallStaging 复制了APK文件到暂存文件中后，后续使用到的就是这个暂存APK文件，并且由于暂存文件在app内部目录且在内部传递，因此URI 可以使用 file 协议

## 三、DeleteStagedFileOnResult

DeleteStagedFileOnResult 代码很少，作用也很简单，用于安装流程结束之后将 InstallStaging 暂存的 APK 文件删除掉。

```java
public class DeleteStagedFileOnResult extends Activity {
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        if (savedInstanceState == null) {
            Intent installIntent = new Intent(getIntent());
            installIntent.setClass(this, PackageInstallerActivity.class);

            installIntent.setFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);
            startActivityForResult(installIntent, 0);
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        setResult(resultCode, data);
        finish();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
		//结束时删除文件。
        if (isFinishing()) {
            File sourceFile = new File(getIntent().getData().getPath());
            new Thread(sourceFile::delete).start();
        }
    }
}
```

DeleteStagedFileOnResult  只是一个过客，在 onCreate 中跳转了 PackageInstallerActivity

## 四、PackageInstallerActivity



### 1. onCreate 获取APK信息

```java
    @Override
    protected void onCreate(Bundle icicle) {
        if (mLocalLOGV) Log.i(TAG, "creating for user " + getUserId());
        getWindow().addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);

        super.onCreate(null);

        if (icicle != null) {
            mAllowUnknownSources = icicle.getBoolean(ALLOW_UNKNOWN_SOURCES_KEY);
        }
		//初始化所需的系统服务对象
        mPm = getPackageManager();
        mIpm = AppGlobals.getPackageManager();
        mAppOpsManager = (AppOpsManager) getSystemService(Context.APP_OPS_SERVICE);
        mInstaller = mPm.getPackageInstaller();
        mUserManager = (UserManager) getSystemService(Context.USER_SERVICE);

        final Intent intent = getIntent();
		//下面这些参数都是在InstallStart中设置的并传递来的
        mCallingPackage = intent.getStringExtra(EXTRA_CALLING_PACKAGE);
        mCallingAttributionTag = intent.getStringExtra(EXTRA_CALLING_ATTRIBUTION_TAG);
        mSourceInfo = intent.getParcelableExtra(EXTRA_ORIGINAL_SOURCE_INFO);
        mOriginatingUid = intent.getIntExtra(Intent.EXTRA_ORIGINATING_UID,
                PackageInstaller.SessionParams.UID_UNKNOWN);
        mOriginatingPackage = (mOriginatingUid != PackageInstaller.SessionParams.UID_UNKNOWN)
                ? getPackageNameForUid(mOriginatingUid) : null;

        final Uri packageUri;

        if (PackageInstaller.ACTION_CONFIRM_INSTALL.equals(intent.getAction())) {
			//...... 
        } else {
            //普通安装的情况
            mSessionId = -1;
            packageUri = intent.getData();
            //获取到 mOriginatingURI
            mOriginatingURI = intent.getParcelableExtra(Intent.EXTRA_ORIGINATING_URI);
            mReferrerURI = intent.getParcelableExtra(Intent.EXTRA_REFERRER);
        }
       	//......
		//解析Uri并判断是否安装
        boolean wasSetUp =  (packageUri);
        if (mLocalLOGV) Log.i(TAG, "wasSetUp: " + wasSetUp);

        if (!wasSetUp) {
            return;
        }
    }

```

在 onCreate 方法中首先初始化需要的一些系统服务对象，如PackageManager、IPackageManager、AppOpsManager 和 UserManager等，它们的作用如下：

| 类名             |                                        |
| ---------------- | -------------------------------------- |
| PackageManager   | 用于向应用程序进程提供PMS的功能        |
| IPackageManager  | 用于和PMS进行进程间通信                |
| AppOpsManager    | 用于动态权限检测，从Android4.3开始引入 |
| PackageInstaller | 提供安装、升级、和删除应用程序的功能   |
| UserManager      | 多用户管理                             |

然后调用 processPackageUri 方法处理 APK 文件，传入的参数为 InstallStaging 复制的APK暂存文件URI，主要作用是获取 APK相关权限信息以及APK的标签（名称）和图标，如下：

```java
   private boolean processPackageUri(final Uri packageUri) {
        mPackageURI = packageUri;

        final String scheme = packageUri.getScheme();
        switch (scheme) {
            case SCHEME_PACKAGE: //......
            case ContentResolver.SCHEME_FILE: {
                File sourceFile = new File(packageUri.getPath());
                mPkgInfo = PackageUtil.getPackageInfo(this, sourceFile,
                        PackageManager.GET_PERMISSIONS);//GET_PERMISSIONS 获取APK的相关权限信息
                if (mPkgInfo == null) {//没有包信息则失败弹窗
                    Log.w(TAG, "Parse error when parsing manifest. Discontinuing installation");
                    showDialogInner(DLG_PACKAGE_ERROR);
                    setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK);
                    return false;
                }
                //mAppSnippet包含了 图标，标签信息
                mAppSnippet = PackageUtil.getAppSnippet(this, mPkgInfo.applicationInfo, sourceFile);
            } break;
            default: {
                throw new IllegalArgumentException("Unexpected URI scheme " + packageUri);
            }
        }
        return true;
    }

```

获取到了被安装应用的权限信息和图标、标签信息之后，后面就可以展示出来了。

### 2. onResume 检查未知来源

在onCreate中处理完APK，获取到相关信息之后，onResume中会展示未知来源APK安装的对话框。

```java
    @Override
    protected void onResume() {
        super.onResume();
        if (mAppSnippet != null) {
            bindUi();
            checkIfAllowedAndInitiateInstall();
        }
        if (mOk != null) {
            mOk.setEnabled(mEnableOk);
        }
    }
```

在 processPakcageUri的方法中获取到的mAppSnippet 不为null，则展示要安装的APK的图标和名称。

checkIfAllowedAndInitiateInstall 方法检查是否允许安装

```java
    private void checkIfAllowedAndInitiateInstall() {
		//返回是谁对用户安装应用进行了限制
        final int installAppsRestrictionSource = mUserManager.getUserRestrictionSource(
                UserManager.DISALLOW_INSTALL_APPS, Process.myUserHandle());
        if ((installAppsRestrictionSource & UserManager.RESTRICTION_SOURCE_SYSTEM) != 0) {
            //若是系统对用户限制了，则弹窗提示：此用户无权安装应用
            showDialogInner(DLG_INSTALL_APPS_RESTRICTED_FOR_USER);
            return;
        } else if (installAppsRestrictionSource != UserManager.RESTRICTION_NOT_SET) {
            //若存在限制安装的情况，也不是RESTRICTION_SOURCE_SYSTEM，进入该分支，提示用户，并关闭页面结束安装
            startActivity(new Intent(Settings.ACTION_SHOW_ADMIN_SUPPORT_DETAILS));
            finish();
            return;
        }
		//允许安装位置应用、或者是特权app可以跳过位置来源应用检查则进行安装流程
        //若不是特权app，第一次执行到此处mAllowUnknownSources为false，执行else的代码
        if (mAllowUnknownSources || !isInstallRequestFromUnknownSource(getIntent())) {
            if (mLocalLOGV) Log.i(TAG, "install allowed");
            initiateInstall();
        } else {//普通应用走这里
            //返回是谁对用户不允许安装未知应用的限制
            final int unknownSourcesRestrictionSource = mUserManager.getUserRestrictionSource(
                    UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES, Process.myUserHandle());
            //返回是谁对设备不允许安装未知应用的限制
            final int unknownSourcesGlobalRestrictionSource = mUserManager.getUserRestrictionSource(
                    UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY, Process.myUserHandle());
            //判断是否是系统限制安装未知应用
            final int systemRestriction = UserManager.RESTRICTION_SOURCE_SYSTEM
                    & (unknownSourcesRestrictionSource | unknownSourcesGlobalRestrictionSource);
            if (systemRestriction != 0) {
                //如果系统限制安装未知应用，则弹窗提示用户：该用户无法安装未知应用
                showDialogInner(DLG_UNKNOWN_SOURCES_RESTRICTED_FOR_USER);
            } else if (unknownSourcesRestrictionSource != UserManager.RESTRICTION_NOT_SET) {
                //如果对用户范围限制了安装未知应用，则跳转设置界面
                startAdminSupportDetailsActivity(UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES);
            } else if (unknownSourcesGlobalRestrictionSource != UserManager.RESTRICTION_NOT_SET) {
                //如果对设备范围了限制安装未知应用，则跳转设置界面
                startAdminSupportDetailsActivity(UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY);
            } else {
                //没有限制安装未知应用的情况下，走handleUnknownSources方法
                handleUnknownSources();
            }
        }
    }
```

checkIfAllowedAndInitiateInstall 方法的功能：

1. 检查是否有安装应用的限制
2. 若允许安装未知应用，或者是特权应用，则跳过未知来源应用检查，直接安装
3. 检查是否有安装未知来源应用的限制
4. 调用handleUnknownSources 方法处理安装未知来源应用

### 3. handleUnknownSources 处理未知来源

```java
    private void handleUnknownSources() {
        if (mOriginatingPackage == null) {
            //调起安装的来源包名为null，是匿名的，弹窗提醒用户：来历不明的应用很可能会损害您的手机和个人数据。安装该应用即表示，您同意对于因使用该应用可能导致的任何手机损坏或数据丢失情况，您负有全部责任
            //点击继续按钮则重启页面，并设置mAllowUnknownSources 为true，跳过未知来源检查，直接安装
            showDialogInner(DLG_ANONYMOUS_SOURCE);
            return;
        }
    	//检查调用安装的应用进程是否有权限安装应用
        final int appOpCode =
                AppOpsManager.permissionToOpCode(Manifest.permission.REQUEST_INSTALL_PACKAGES);
        final int appOpMode = mAppOpsManager.noteOpNoThrow(appOpCode, mOriginatingUid,
                mOriginatingPackage, mCallingAttributionTag,
                "Started package installation activity");
        switch (appOpMode) {
            //检查权限默认情况和错误情况，不允许安装，弹窗提示用户
            case AppOpsManager.MODE_DEFAULT:
                mAppOpsManager.setMode(appOpCode, mOriginatingUid,
                        mOriginatingPackage, AppOpsManager.MODE_ERRORED);
            case AppOpsManager.MODE_ERRORED:
                showDialogInner(DLG_EXTERNAL_SOURCE_BLOCKED);//出于安全考虑，已禁止您的手机安装来自此来源的未知应用。
                break;
            case AppOpsManager.MODE_ALLOWED:
                //进行安装
                initiateInstall();
                break;
            default:
                Log.e(TAG, "Invalid app op mode " + appOpMode
                        + " for OP_REQUEST_INSTALL_PACKAGES found for uid " + mOriginatingUid);
                finish();
                break;
        }
    }

```

handleUnknownSources 方法的逻辑点：

1. 判断是否调用安装进程的包名为空，为空则弹窗提示用户，用户点击继续按钮则继续安装
2. 检查调用安装的进程安装权限，默认和错误的情况弹窗提示用户,如一开始的安装过程图片第二张，点击设置按钮跳转设置页返回后继续安装
3. 第二步中权限允许则调用 initiateInstall 进行安装

### 4. initiateInstall 检查是否已安装

```java
private void initiateInstall() {
    String pkgName = mPkgInfo.packageName;
    String[] oldName = mPm.canonicalToCurrentPackageNames(new String[] { pkgName });
    if (oldName != null && oldName.length > 0 && oldName[0] != null) {
        pkgName = oldName[0];
        mPkgInfo.packageName = pkgName;
        mPkgInfo.applicationInfo.packageName = pkgName;
    }
    try {
        //Flag是MATCH_UNINSTALLED_PACKAGES，检查是否存在数据，即删除apk时选择保留数据的，也算已安装的
        mAppInfo = mPm.getApplicationInfo(pkgName,
                PackageManager.MATCH_UNINSTALLED_PACKAGES);
        if ((mAppInfo.flags&ApplicationInfo.FLAG_INSTALLED) == 0) {
            mAppInfo = null;
        }
    } catch (NameNotFoundException e) {
        mAppInfo = null;
    }

    startInstallConfirm();
}
```

initiateInstall 就是检查设备是否已安装了这个应用，即便已经删除，但是保留了数据的也算在内，如果应用已经安装，通过mAppInfo记录。

接着调用 startInstallConfirm

### 5. startInstallConfirm 确认安装

```java
 private void startInstallConfirm() {
        View viewToEnable;

        if (mAppInfo != null) {
            viewToEnable = requireViewById(R.id.install_confirm_question_update);
            mOk.setText(R.string.update);
        } else {
            viewToEnable = requireViewById(R.id.install_confirm_question);
        }

        viewToEnable.setVisibility(View.VISIBLE);

        mEnableOk = true;
        mOk.setEnabled(true);
        mOk.setFilterTouchesWhenObscured(true);
    }
```

startInstallConfirm 是安装前的最后一步确认，如一开始展示的第四张图片，若mAppInfo不为空，则提示更新，若是空则提示安装。

很明显，安装的确认按钮是**mOK** ，我们来看 mOk的点击事件

PackageInstallerActivity中的弹窗样式是在onResume方法中调用 bindUi设置的

```java
    private void bindUi() {
        mAlert.setIcon(mAppSnippet.icon);
        mAlert.setTitle(mAppSnippet.label);
        mAlert.setView(R.layout.install_content_view);
        mAlert.setButton(DialogInterface.BUTTON_POSITIVE, getString(R.string.install),
                (ignored, ignored2) -> {
                    if (mOk.isEnabled()) {
                        if (mSessionId != -1) {
                            mInstaller.setPermissionsResult(mSessionId, true);
                            finish();
                        } else {
                            startInstall();
                        }
                    }
                }, null);
		//......
        mOk = mAlert.getButton(DialogInterface.BUTTON_POSITIVE);
		//......
    }
```

可以看到，非Session安装的情况下，点击确认按钮，会调用 startInstall

### 6. startInstall 开始安装

```java
private void startInstall() {
    Intent newIntent = new Intent();
    newIntent.putExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO,
            mPkgInfo.applicationInfo);
    newIntent.setData(mPackageURI);
    newIntent.setClass(this, InstallInstalling.class);
    String installerPackageName = getIntent().getStringExtra(
            Intent.EXTRA_INSTALLER_PACKAGE_NAME);
    if (mOriginatingURI != null) {
        newIntent.putExtra(Intent.EXTRA_ORIGINATING_URI, mOriginatingURI);
    }
    if (mReferrerURI != null) {
        newIntent.putExtra(Intent.EXTRA_REFERRER, mReferrerURI);
    }
    if (mOriginatingUid != PackageInstaller.SessionParams.UID_UNKNOWN) {
        newIntent.putExtra(Intent.EXTRA_ORIGINATING_UID, mOriginatingUid);
    }
    if (installerPackageName != null) {
        newIntent.putExtra(Intent.EXTRA_INSTALLER_PACKAGE_NAME,
                installerPackageName);
    }
    if (getIntent().getBooleanExtra(Intent.EXTRA_RETURN_RESULT, false)) {
        newIntent.putExtra(Intent.EXTRA_RETURN_RESULT, true);
    }
    newIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);
    if (mLocalLOGV) Log.i(TAG, "downloaded app uri=" + mPackageURI);
    startActivity(newIntent);
    finish();
}
```

startInstall方法打开了 InstallInstalling 进行安装

### 7.小总结

1. 在 onCreate 中初始化需要用到的系统服务对象，如PackageManager
2. 在onCreate中 使用 PackageUtil.getPackageInfo 获取APK的权限信息；使用 PackageUtil.getAppSnippet 获取APK的图标和标签。
3. checkIfAllowedAndInitiateInstall 中检查系统、设备、用户是否存在对安装的限制
4. handleUnknownSources 中检查APK来源，展示未知来源对话框，当点击 setting 按钮后跳转设置页
5. 设置中允许安装未知来源应用后，或者本来就允许时，initiateInstall 中检查是否安装过。
6. startInstallConfirm 中确认安装，若已经安装，则按钮为更新
7. startInstall  跳转 InstallInstalling 页面开始安装

## 五、InstallInstalling

InstallInstalling弹窗样式就是安装过程的第五张图片，顾名思义它表示应用正在安装。

### 1. onCreate 创建Session

```java
  @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        ApplicationInfo appInfo = getIntent()
                .getParcelableExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO);
        mPackageURI = getIntent().getData();

        if ("package".equals(mPackageURI.getScheme())) {
           //......
        } else {
            final File sourceFile = new File(mPackageURI.getPath());
            PackageUtil.AppSnippet as = PackageUtil.getAppSnippet(this, appInfo, sourceFile);

            mAlert.setIcon(as.icon);
            mAlert.setTitle(as.label);
            mAlert.setView(R.layout.install_content_view);
            mAlert.setButton(DialogInterface.BUTTON_NEGATIVE, getString(R.string.cancel),
                    (ignored, ignored2) -> {
                        if (mInstallingTask != null) {
                            mInstallingTask.cancel(true);
                        }

                        if (mSessionId > 0) {
                            getPackageManager().getPackageInstaller().abandonSession(mSessionId);
                            mSessionId = 0;
                        }

                        setResult(RESULT_CANCELED);
                        finish();
                    }, null);
            setupAlert();
            requireViewById(R.id.installing).setVisibility(View.VISIBLE);

            if (savedInstanceState != null) {
                //Activity重建，savedInstanceState不为空的情况，获取保存的 mSessionId 和 mInstallId
                mSessionId = savedInstanceState.getInt(SESSION_ID);
                mInstallId = savedInstanceState.getInt(INSTALL_ID);

          		//重新注册 InstallEventReceiver 的观察者
                try {
                    InstallEventReceiver.addObserver(this, mInstallId,
                            this::launchFinishBasedOnResult);
                } catch (EventResultPersister.OutOfIdsException e) {}
            } else {
                //创建 SessionParams 并设置参数
                PackageInstaller.SessionParams params = new PackageInstaller.SessionParams(
                        PackageInstaller.SessionParams.MODE_FULL_INSTALL);
                params.setInstallAsInstantApp(false);
                params.setReferrerUri(getIntent().getParcelableExtra(Intent.EXTRA_REFERRER));
                params.setOriginatingUri(getIntent()
                        .getParcelableExtra(Intent.EXTRA_ORIGINATING_URI));
                params.setOriginatingUid(getIntent().getIntExtra(Intent.EXTRA_ORIGINATING_UID,
                        UID_UNKNOWN));
                params.setInstallerPackageName(getIntent().getStringExtra(
                        Intent.EXTRA_INSTALLER_PACKAGE_NAME));
                params.setInstallReason(PackageManager.INSTALL_REASON_USER);

                File file = new File(mPackageURI.getPath());
                try {
                    //计算APK的大小
                    final ParseTypeImpl input = ParseTypeImpl.forDefaultParsing();
                    //获取APK的轻量信息PackageLite
                    final ParseResult<PackageLite> result = ApkLiteParseUtils.parsePackageLite(
                            input.reset(), file, /* flags */ 0);
                    if (result.isError()) {
                        //获取失败则设置传输文件大小为APK文件大小
                        params.setSize(file.length());
                    } else {
                        final PackageLite pkg = result.getResult();
                        params.setAppPackageName(pkg.getPackageName());
                        params.setInstallLocation(pkg.getInstallLocation());
                        //设置传输大小为计算出来的
                        params.setSize(
                                PackageHelper.calculateInstalledSize(pkg, params.abiOverride));
                    }
                } catch (IOException e) {
               		//发生异常则设置传输文件大小为APK文件大小
                    params.setSize(file.length());
                }

                try {
                    //向InstallEventReceiver 注册一个观察者，得到一个id，命名为mInstallId
                    mInstallId = InstallEventReceiver
                            .addObserver(this, EventResultPersister.GENERATE_NEW_ID,
                                    this::launchFinishBasedOnResult);
                } catch (EventResultPersister.OutOfIdsException e) {
                    launchFailure(PackageInstaller.STATUS_FAILURE,
                            PackageManager.INSTALL_FAILED_INTERNAL_ERROR, null);
                }

                try {
                    //使用 PackageInstaller 根据 SessionParams 创建一个 Session，得到一个id，命名为mSessionId
                    mSessionId = getPackageManager().getPackageInstaller().createSession(params);
                } catch (IOException e) {
                    launchFailure(PackageInstaller.STATUS_FAILURE,
                            PackageManager.INSTALL_FAILED_INTERNAL_ERROR, null);
                }
            }

            mCancelButton = mAlert.getButton(DialogInterface.BUTTON_NEGATIVE);
        }
    }
```

1. 首先创建一个SessionParams对象作为创建Session的参数对象
2. 通过 ApkLiteParseUtils.parsePackageLite 得到轻量级的APK信息对象PackageLite，并计算安装大小设置道SessionParams中。若解析不到apk信息，或者计算安装大小失败，则设置apk的文件大小
3. 向 InstallEventReceiver 注册一个观察者，用于监听APK安装事件，并得到 mInstallId
4. 通过 PackageInstaller 根据 SessionParams 创建一个 Session，得到 mSessionId
5. 若是Activity重建的情况，则直接从savedInstanceState中获取mInstallId 和 mSessionId

#### 1.1 InstallEventReceiver

InstallEventReceiver 继承 BroadcastReveiver ，用于接收安装事件并回调给 EventResultPersister。我们可以PackageInstaller的AndroidManifest中，看到InstallEventReceiver 是一个静态注册的广播，action 为 com.android.packageinstaller.ACTION_INSTALL_COMMIT

```xml
<receiver android:name=".InstallEventReceiver" android:exported="true" android:permission="android.permission.INSTALL_PACKAGES">
	<intent-filter android:priority="1">
		<action android:name="com.android.packageinstaller.ACTION_INSTALL_COMMIT"/>
	</intent-filter>
</receiver>
```

看它的 addObserver方法

```java
static int addObserver(@NonNull Context context, int id,
        @NonNull EventResultPersister.EventResultObserver observer)
        throws EventResultPersister.OutOfIdsException {
    return getReceiver(context).addObserver(id, observer);
}

@NonNull private static EventResultPersister getReceiver(@NonNull Context context) {
    synchronized (sLock) {
        if (sReceiver == null) {
            sReceiver = new EventResultPersister(
                    TemporaryFileManager.getInstallStateFile(context));
        }
    }
    return sReceiver;
}
```

可以看到，最终是调用的 EventResultPersister 的 addObserver 方法，EventResultPersister 创建需要传入一个文件， TemporaryFileManager.getInstallStateFile(context)  返回的是 /data/user_de/0/com.google.android.packageinstaller/no_backup/install_result.xml 文件

```java
<results counter="-2147483636" />
```

xml中记录了一个counter的值，每当添加了一个新的观察者，即传入的id为EventResultPersister.GENERATE_NEW_ID，该值就加1

#### 1.2 createSession

onCreate的最后会通过 PackageInstaller 创建 Session 并返回 mSessionId。

##### 1.2.1 getPackageManager

首先是调用了 Context 的 getPackageManager方法，该方法的实现在 ContextImpl中，位置在 \frameworks\base\core\java\android\app\ContextImpl.java 中，得到ApplicationPackageManager对象

```java
public PackageManager getPackageManager() {
    if (mPackageManager != null) {
        return mPackageManager;
    }
    //首先通过 ActivityThread 的静态同名方法获得 一个 IPackageManager 接口对象，即 PackageManagerService 的 Binder 代理对象
    final IPackageManager pm = ActivityThread.getPackageManager();
    if (pm != null) {
        //创建了一个 ApplicationPackageManager 对象，它包装了获得的PMS代理对象，并且后续再次调用getPackageManager 就直接返回这个对象。
        return (mPackageManager = new ApplicationPackageManager(this, pm));
    }
    return null;
}
```
##### 1.2.2 getPackageInstaller

ApplicationPackageManager 是 PackageManagerService的代理对象，调用它的 getPackageInstaller 获取 PackageInstaller 对象

```java
   @Override
    public PackageInstaller getPackageInstaller() {
        synchronized (mLock) {
            if (mInstaller == null) {
                try {
                    //创建PackageInstaller对象，传入参数PackageInstallerService
                    mInstaller = new PackageInstaller(mPM.getPackageInstaller(),
                            mContext.getPackageName(), mContext.getAttributionTag(), getUserId());
                } catch (RemoteException e) {
                    throw e.rethrowFromSystemServer();
                }
            }
            return mInstaller;
        }
   }
```

这里得到的 PackageInstaller 也是一个代理对象，他持有 PackageInstallerService Binder代理对象 。*PackageInstaller 的构造器还需要传入当前应用进程的包名。*

PackageManagerService返回PackageInstallerService：

```java
    public IPackageInstaller getPackageInstaller() {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        return mInstallerService;
    }
```

在 PMS 中，直接返回了成员变量 mInstallerService ，它是在 PMS 的构造器中传入且赋值的。PMS的初始化发生在 SystemServer中，并且会调用 PMS 的 main 方法进行初始化：

```java
	    public PackageManagerService(Injector injector, boolean onlyCore, boolean factoryTest,
            final String buildFingerprint, final boolean isEngBuild,
            final boolean isUserDebugBuild, final int sdkVersion, final String incrementalVersion) {
        	//......
        	mInstallerService = mInjector.getPackageInstallerService();
        	//......
        }


	public static PackageManagerService main(Context context, Installer installer,
            @NonNull DomainVerificationService domainVerificationService, boolean factoryTest,
            boolean onlyCore) {
		//......
        Injector injector = new Injector(
                context, lock, installer, installLock, new PackageAbiHelperImpl(),
                backgroundHandler,
             	//......
                (i, pm) -> new PackageInstallerService(
                        i.getContext(), pm, i::getScanningPackageParser),
             	//......
                },
                new DefaultSystemWrapper(),
                LocalServices::getService,
                context::getSystemService);


        if (Build.VERSION.SDK_INT <= 0) {
            Slog.w(TAG, "**** ro.build.version.sdk not set!");
        }

        PackageManagerService m = new PackageManagerService(injector, onlyCore, factoryTest,
                Build.FINGERPRINT, Build.IS_ENG, Build.IS_USERDEBUG, Build.VERSION.SDK_INT,
                Build.VERSION.INCREMENTAL);
		//......
        return m;
    }
```

PackageManagerService 的 main 方法中创建了一个 Injector 对象用来为 PackageManagerService 注入一些成员。在 PackageManagerService  构造器中，通过 Injector 的 getPackageInstallerService 创建 PackageInstallerService 对象并赋值给成员变量 mInstallerService。

##### 1.2.3 createSession

获取到 PackageInstaller 之后，调用了它的 createSession 方法创建 Session：

```java
    public int createSession(@NonNull SessionParams params) throws IOException {
        try {
            return mInstaller.createSession(params, mInstallerPackageName, mAttributionTag,
                    mUserId);
        } catch (RuntimeException e) {
            ExceptionUtils.maybeUnwrapIOException(e);
            throw e;
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
```

mInstaller是保存在 PackageInstaller 中的系统服务中的 PackageInstallerService 的Binder代理对象。通过Binder 调用到了系统服务中 PackageInstallerService 的相应方法：

```java
   @Override
    public int createSession(SessionParams params, String installerPackageName,
            String callingAttributionTag, int userId) {
        try {
            return createSessionInternal(params, installerPackageName, callingAttributionTag,
                    userId);
        } catch (IOException e) {
            throw ExceptionUtils.wrap(e);
        }
    }


    private int createSessionInternal(SessionParams params, String installerPackageName,
            String installerAttributionTag, int userId)
            throws IOException {
  		//......

        final int sessionId;
        final PackageInstallerSession session;
        synchronized (mSessions) {
            //......
            sessionId = allocateSessionIdLocked();
        }

        final long createdMillis = System.currentTimeMillis();
        //......
        File stageDir = null;
        String stageCid = null;
        if (!params.isMultiPackage) {
            //根据标志位决定拷贝文件存放的位置
            if ((params.installFlags & PackageManager.INSTALL_INTERNAL) != 0) {
                //实际上一定走这里 生成stageDir文件
                stageDir = buildSessionDir(sessionId, params);
            } else {
                stageCid = buildExternalStageCid(sessionId);
            }
        }

        
        InstallSource installSource = InstallSource.create(installerPackageName,
                originatingPackageName, requestedInstallerPackageName,
                installerAttributionTag);
        session = new PackageInstallerSession(mInternalCallback, mContext, mPm, this,
                mSilentUpdatePolicy, mInstallThread.getLooper(), mStagingManager, sessionId,
                userId, callingUid, installSource, params, createdMillis, 0L, stageDir, stageCid,
                null, null, false, false, false, false, null, SessionInfo.INVALID_ID,
                false, false, false, SessionInfo.STAGED_SESSION_NO_ERROR, "");
		
        //记录sessionId和session
        synchronized (mSessions) {
            mSessions.put(sessionId, session);
        }

        mCallbacks.notifySessionCreated(session.sessionId, session.userId);

        mSettingsWriteRequest.schedule();
        return sessionId;
    }

```

Session的创建需要一个stageDir用于保存传入的apk文件，该目录的地址在 /data/app/vmdl+sessionid+.tmp

PackageInstaller 通过它内部持有的 PackageInstallerService 的代理对象创建 session。session的类型是 PackageInstallerSession ，PackageInstallerService创建后 session后 会以sessionId作为key，session作为value，保存在一个SparseArray，命名为mSessions，最后返回 sessionId 到 PackageInstaller。

### 2. onResume 执行安装任务

```java
    @Override
    protected void onResume() {
        super.onResume();

        if (mInstallingTask == null) {
            PackageInstaller installer = getPackageManager().getPackageInstaller();
            //通过sessionId获取sessionInfo
            PackageInstaller.SessionInfo sessionInfo = installer.getSessionInfo(mSessionId);
			//sessionInfo 不为空且不是活动的，执行安装任务
            if (sessionInfo != null && !sessionInfo.isActive()) {
                mInstallingTask = new InstallingAsyncTask();
                mInstallingTask.execute();
            } else {
                mCancelButton.setEnabled(false);
                setFinishOnTouchOutside(false);
            }
        }
    }
```

在 onCreate 中已经通过 PackageInstaller 的 createSession 方法 创建一个 Session 并得到了mSessionId，这里通过 mSessionId获取到 SessionInfo。SessionInfo 代表了安装会话的详细信息，若不为空并且不是活动的，就创建 InstallingAsyncTask 并执行。

#### 2.1 InstallingAsyncTask 

##### 2.1.1 doInBackground 

接着看 InstallingAsyncTask 的 doInBackground 方法：

```java
        @Override
        protected PackageInstaller.Session doInBackground(Void... params) {
            PackageInstaller.Session session;
            try {
                //调用openSession 创建Session保存apk相关文件的目录
                session = getPackageManager().getPackageInstaller().openSession(mSessionId);
            } catch (IOException e) {
                synchronized (this) {
                    isDone = true;
                    notifyAll();
                }
                return null;
            }
			//设置进度为0
            session.setStagingProgress(0);
            try {
                File file = new File(mPackageURI.getPath());
				//从文件获取输入流
                try (InputStream in = new FileInputStream(file)) {
                    long sizeBytes = file.length();
                    //从session获取输出流
                    try (OutputStream out = session
                            .openWrite("PackageInstaller", 0, sizeBytes)) {
                        byte[] buffer = new byte[1024 * 1024];
                        //开始将文件传递给session
                        while (true) {
                            int numRead = in.read(buffer);

                            if (numRead == -1) {
                                session.fsync(out);
                                break;
                            }

                            if (isCancelled()) {
                                session.close();
                                break;
                            }

                            out.write(buffer, 0, numRead);
                            if (sizeBytes > 0) {
                                float fraction = ((float) numRead / (float) sizeBytes);
                                //设置文件传输的进度
                                session.addProgress(fraction);
                            }
                        }
                    }
                }
                return session;
            } 
            //......
        }

```

1. 首先通过 PackageInstallerSession 的 openSession方法，创建stageDir目录，目录为/data/app/vmdl+sessionId+.tmp/
2. 调用  PackageInstallerSession 的 openWrite 方法，在stageDir目录下创建PackageInstaller,并预先分配好空间

###### 2.1.1.1 openSession 

首先调用PackageInstallerService 的 openSession 方法

```java
    @Override
    public IPackageInstallerSession openSession(int sessionId) {
        try {
            return openSessionInternal(sessionId);
        } catch (IOException e) {
            throw ExceptionUtils.wrap(e);
        }
    }

    private IPackageInstallerSession openSessionInternal(int sessionId) throws IOException {
        synchronized (mSessions) {
            final PackageInstallerSession session = mSessions.get(sessionId);
            if (session == null || !isCallingUidOwner(session)) {
                throw new SecurityException("Caller has no access to session " + sessionId);
            }
            session.open();
            return session;
        }
    }

```

可以看到最终是根据记录的 sessionId，获取到记录中的session，调用它的 open 方法

```java

    public void open() throws IOException {
        if (mActiveCount.getAndIncrement() == 0) {
            mCallback.onSessionActiveChanged(this, true);
        }
        boolean wasPrepared;
        synchronized (mLock) {
            wasPrepared = mPrepared;
            if (!mPrepared) {
                if (stageDir != null) {
                    prepareStageDir(stageDir);
                } else if (params.isMultiPackage) {
                    // it's all ok
                } else {//必须要有stageDir
                    throw new IllegalArgumentException("stageDir must be set");
                }

                mPrepared = true;
            }
        }
        if (!wasPrepared) {
            mCallback.onSessionPrepared(this);
        }
    }
	//prepareStageDir是PackageInstallerService的静态方法
    static void prepareStageDir(File stageDir) throws IOException {
		//......
        try {
            Os.mkdir(stageDir.getAbsolutePath(), 0775);
            Os.chmod(stageDir.getAbsolutePath(), 0775);
        } catch (ErrnoException e) {}
    }

```

在生成Session对象的时候，会确定 stageDir目录地址，在这里会创建该目录。

##### 2.1.2 onPostExecute 

```java
        @Override
        protected void onPostExecute(PackageInstaller.Session session) {
            if (session != null) {
                //注意这个action，它就是之前的InstallEventReceiver广播的action
                Intent broadcastIntent = new Intent(BROADCAST_ACTION);
                broadcastIntent.setFlags(Intent.FLAG_RECEIVER_FOREGROUND);
                broadcastIntent.setPackage(getPackageName());
                broadcastIntent.putExtra(EventResultPersister.EXTRA_ID, mInstallId);
				//创建一个发送广播的PendingIntent
                PendingIntent pendingIntent = PendingIntent.getBroadcast(
                        InstallInstalling.this,
                        mInstallId,
                        broadcastIntent,
                        PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_MUTABLE);
				//将广播的IntentSender提交到session
                session.commit(pendingIntent.getIntentSender());
                mCancelButton.setEnabled(false);
                setFinishOnTouchOutside(false);
            } else {
                getPackageManager().getPackageInstaller().abandonSession(mSessionId);

                if (!isCancelled()) {
                    launchFailure(PackageInstaller.STATUS_FAILURE,
                            PackageManager.INSTALL_FAILED_INVALID_APK, null);
                }
            }
        }

```

onPostExecute 中创建了个 PendingIntent 并包装了一个发送广播的 Intent，**我们可以看到这个广播的 action 正是 onCreate 中注册的InstallEventReceiver 的action**。PendingIntent 允许其他进程使用包装进去的 Intent，session 将 PendingIntent 的 IntentSender 通过commit 方法传输出去，**并将安装过程交给session**。

## 六、PackageInstallerSession

### 1. commit

InstallInstalling将apk文件传输到Session后，调用commit方法，接下来安装进入到系统服务这一进程中。

```java
@Override
public void commit(@NonNull IntentSender statusReceiver, boolean forTransfer) {
    if (hasParentSessionId()) {
        throw new IllegalStateException(
                "Session " + sessionId + " is a child of multi-package session "
                        + getParentSessionId() +  " and may not be committed directly.");
    }
	//密封这个Session
    if (!markAsSealed(statusReceiver, forTransfer)) {
        return;
    }
	//......
    //分发session被密封的事件
    dispatchSessionSealed();
}
```

简单说明一下 markAsSealed 这个方法，其实就是记录一下 IntentSender，作为成员变量 mRemoteStatusReceiver，后续在PMS中安装完成应用后，可以通过这个将安装完成的广播发送出去

然后设置标志位 mSealed 为true，那么之后就无法更改这个session了

然后调用dispatchSessionSealed 分发事件：

```java
    private void dispatchSessionSealed() {
        mHandler.obtainMessage(MSG_ON_SESSION_SEALED).sendToTarget();
    }

    private void handleSessionSealed() {
        assertSealed("dispatchSessionSealed");
        mCallback.onSessionSealedBlocking(this);
        dispatchStreamValidateAndCommit();
    }

    private void dispatchStreamValidateAndCommit() {
        mHandler.obtainMessage(MSG_STREAM_VALIDATE_AND_COMMIT).sendToTarget();
    }


    private void handleStreamValidateAndCommit() {
        PackageManagerException unrecoverableFailure = null;
        boolean allSessionsReady = false;
        try {
            allSessionsReady = streamValidateAndCommit();
        } catch (PackageManagerException e) {
            unrecoverableFailure = e;
        }
		//......
        mHandler.obtainMessage(MSG_INSTALL).sendToTarget();
    }

    private boolean streamValidateAndCommit() throws PackageManagerException {
        try {
            synchronized (mLock) {
                if (mCommitted) {
                    return true;
                }
                //增加mActiveCount计数，这个计数大于0是，则session是活动状态
                mActiveCount.incrementAndGet();
				//设置mCommitted标志为true
                mCommitted = true;
                committedMillis = System.currentTimeMillis();
            }
            return true;
        }
        //......
    }

    private void handleInstall() {
        //......
        verify();
    }

  private final Handler.Callback mHandlerCallback = new Handler.Callback() {
        @Override
        public boolean handleMessage(Message msg) {
            switch (msg.what) {
                case MSG_ON_SESSION_SEALED:
                    handleSessionSealed();
                    break;
                case MSG_STREAM_VALIDATE_AND_COMMIT:
                    handleStreamValidateAndCommit();
                    break;
                case MSG_INSTALL:
                    handleInstall();
                    break;
 				//......
            }

            return true;
        }
    };

```

1. dispatchSessionSealed 发送 MSG_ON_SESSION_SEALED 消息，调用 dispatchStreamValidateAndCommit 
2. dispatchStreamValidateAndCommit  发送 MSG_STREAM_VALIDATE_AND_COMMIT 消息调用 handleStreamValidateAndCommit
3. handleStreamValidateAndCommit 中调用 streamValidateAndCommit方法增加**mActiveCount计数** 和设置 mCommitted 标志为true，mActiveCount用于判断session是否为活动状态，在InstallInstalling的onResume中的session.isActive就是判断该计数是否大于0
4. handleStreamValidateAndCommit  发送 MSG_INSTALL 消息，调用 handleInstall 最终调用 verify

### 2. verify 进行验证

```java
    private void verify() {
        try {
            verifyNonStaged();
        } catch (PackageManagerException e) {
            final String completeMsg = ExceptionUtils.getCompleteMessage(e);
            onSessionVerificationFailure(e.error, completeMsg);
        }
    }

   private void verifyNonStaged()
            throws PackageManagerException {
        final PackageManagerService.VerificationParams verifyingSession =
                prepareForVerification();
        if (verifyingSession == null) {
            return;
        }
        if (isMultiPackage()) {
			//......多包安装，不分析
        } else {
            mPm.verifyStage(verifyingSession);
        }
    }
```

这里首先调用 prepareForVerification 创建了 **PackageManagerService.VerificationParams 对象**，然后把它作为参数，调用 PackageManagerService 的 verifyStage 方法，将安装过程交给PackageManagerService

#### 2.1 VerificationParams的创建

```java
    private PackageManagerService.VerificationParams prepareForVerification()
            throws PackageManagerException {
        assertNotLocked("makeSessionActive");
		//......
        synchronized (mLock) {
            return makeVerificationParamsLocked();
        }
    }

   private PackageManagerService.VerificationParams makeVerificationParamsLocked() {
        final IPackageInstallObserver2 localObserver;
        if (!hasParentSessionId()) {
            localObserver = new IPackageInstallObserver2.Stub() {
                @Override
                public void onUserActionRequired(Intent intent) {
                    throw new IllegalStateException();
                }

                @Override
                public void onPackageInstalled(String basePackageName, int returnCode, String msg,
                        Bundle extras) {
                    if (returnCode == INSTALL_SUCCEEDED) {//验证成功调用onVerificationComplete
                        onVerificationComplete();
                    } else {
                        onSessionVerificationFailure(returnCode, msg);
                    }
                }
            };
        }
		//......
        return mPm.new VerificationParams(user, stageDir, localObserver, copiedParams,
                mInstallSource, mInstallerUid, mSigningDetails, sessionId, mPackageLite);
    }
```

VerificationParams的需要传入一个 IPackageInstallObserver2 对象，用于接收验证结果，当验证结束时，onPackageInstalled被调用，判断 ` returnCode == INSTALL_SUCCEEDED `成功则调用 onVerificationComplete方法

```java
    private void onVerificationComplete() {
        //......
        install();
    }
```

### 3.install进行安装

当 PackageManagerService 对APK验证完成之后，回调给 PackageInstallerSession 并调用 install 方法

```java

    private void install() {
        try {
            installNonStaged();
        } catch (PackageManagerException e) {
            final String completeMsg = ExceptionUtils.getCompleteMessage(e);
            onSessionInstallationFailure(e.error, completeMsg);
        }
    }

    private void installNonStaged()
            throws PackageManagerException {
        final PackageManagerService.InstallParams installingSession = makeInstallParams();
        //......
        if (isMultiPackage()) {
 			//......
        } else {
            mPm.installStage(installingSession);
        }
    }
```

这里创建了 **PackageManagerService.InstallParams 对象，InstallParams 和 VerificationParams 都继承自 HandlerParams**，同样InstallParams 创建也需要一个 IPackageInstallObserver2。

#### 3.1 InstallParams 的创建

makeInstallParams 方法返回一个 InstallParams 对象：

```java
    private PackageManagerService.InstallParams makeInstallParams()
            throws PackageManagerException {
		//......

        final IPackageInstallObserver2 localObserver = new IPackageInstallObserver2.Stub() {
            @Override
            public void onUserActionRequired(Intent intent) {
                throw new IllegalStateException();
            }

            @Override
            public void onPackageInstalled(String basePackageName, int returnCode, String msg,
                    Bundle extras) {
                if (isStaged()) {
                    sendUpdateToRemoteStatusReceiver(returnCode, msg, extras);
                } else {
                    //这里无论安装成功或者失败，都消灭Session
                    destroyInternal();
                    //分发Session结束事件，这里传来的PendingIntent，这里会发出去
                    dispatchSessionFinished(returnCode, msg, extras);
                }
            }
        };

		//......
        synchronized (mLock) {
            return mPm.new InstallParams(stageDir, localObserver, params, mInstallSource, user,
                    mSigningDetails, mInstallerUid, mPackageLite);
        }
    }
```

onPackageInstalled 在安装结束之后被调用，这里不区分成功或失败，因为安装都已经结束了！

### 4. dispatchSessionFinished 分发Session结束事件

```java
private void dispatchSessionFinished(int returnCode, String msg, Bundle extras) {
    sendUpdateToRemoteStatusReceiver(returnCode, msg, extras);

    synchronized (mLock) {
        mFinalStatus = returnCode;
        mFinalMessage = msg;
    }

    final boolean success = (returnCode == INSTALL_SUCCEEDED);

    final boolean isNewInstall = extras == null || !extras.getBoolean(Intent.EXTRA_REPLACING);
    if (success && isNewInstall && mPm.mInstallerService.okToSendBroadcasts()) {
        mPm.sendSessionCommitBroadcast(generateInfoScrubbed(true /*icon*/), userId);
    }

    mCallback.onSessionFinished(this, success);
    if (isDataLoaderInstallation()) {
        logDataLoaderInstallationSession(returnCode);
    }
}
```

dispatchSessionFinished 会调用 sendUpdateToRemoteStatusReceiver 方法，还记得在InstallInstaling中的AsyncTask 的onPostExecute中，我们将一个广播发送器传递给Session吗？这里就用它来发送广播！

```java
    private void sendUpdateToRemoteStatusReceiver(int returnCode, String msg, Bundle extras) {
        final IntentSender statusReceiver;
        final String packageName;
        synchronized (mLock) {
            statusReceiver = mRemoteStatusReceiver;
            packageName = mPackageName;
        }
        if (statusReceiver != null) {
            final SomeArgs args = SomeArgs.obtain();
            args.arg1 = packageName;
            args.arg2 = msg;
            args.arg3 = extras;
            args.arg4 = statusReceiver;
            args.argi1 = returnCode;
            mHandler.obtainMessage(MSG_ON_PACKAGE_INSTALLED, args).sendToTarget();
        }
    }

    private final Handler.Callback mHandlerCallback = new Handler.Callback() {
        @Override
        public boolean handleMessage(Message msg) {
            switch (msg.what) {
				//......
                case MSG_ON_PACKAGE_INSTALLED:
                    final SomeArgs args = (SomeArgs) msg.obj;
                    final String packageName = (String) args.arg1;
                    final String message = (String) args.arg2;
                    final Bundle extras = (Bundle) args.arg3;
                    final IntentSender statusReceiver = (IntentSender) args.arg4;
                    final int returnCode = args.argi1;
                    args.recycle();

                    sendOnPackageInstalled(mContext, statusReceiver, sessionId,
                            isInstallerDeviceOwnerOrAffiliatedProfileOwner(), userId,
                            packageName, returnCode, message, extras);

                    break;
                case MSG_SESSION_VALIDATION_FAILURE:
                    final int error = msg.arg1;
                    final String detailMessage = (String) msg.obj;
                    onSessionValidationFailure(error, detailMessage);
                    break;
            }

            return true;
        }
    };

    private static void sendOnPackageInstalled(Context context, IntentSender target, int sessionId,
            boolean showNotification, int userId, String basePackageName, int returnCode,
            String msg, Bundle extras) {
       
        if (INSTALL_SUCCEEDED == returnCode && showNotification) {
            //......
            //安装成功，若要显示通知，则弹出通知
        }
        final Intent fillIn = new Intent();
        fillIn.putExtra(PackageInstaller.EXTRA_PACKAGE_NAME, basePackageName);
        fillIn.putExtra(PackageInstaller.EXTRA_SESSION_ID, sessionId);
        fillIn.putExtra(PackageInstaller.EXTRA_STATUS,
                PackageManager.installStatusToPublicStatus(returnCode));
        fillIn.putExtra(PackageInstaller.EXTRA_STATUS_MESSAGE,
                PackageManager.installStatusToString(returnCode, msg));
        fillIn.putExtra(PackageInstaller.EXTRA_LEGACY_STATUS, returnCode);
        if (extras != null) {
            final String existing = extras.getString(
                    PackageManager.EXTRA_FAILURE_EXISTING_PACKAGE);
            if (!TextUtils.isEmpty(existing)) {
                fillIn.putExtra(PackageInstaller.EXTRA_OTHER_PACKAGE_NAME, existing);
            }
        }
        try {
            //发送广播
            target.sendIntent(context, 0, fillIn, null, null);
        } catch (IntentSender.SendIntentException ignored) {
        }
    }


```

### 5. InstallEventReceiver 接收安装结束广播

```java
    @Override
    public void onReceive(Context context, Intent intent) {
        getReceiver(context).onEventReceived(context, intent);
    }
```

之前我们已经知道 getReceiveer获得了一个 EventResultPersister对象，

```java
   void onEventReceived(@NonNull Context context, @NonNull Intent intent) {
        int status = intent.getIntExtra(PackageInstaller.EXTRA_STATUS, 0);

        if (status == PackageInstaller.STATUS_PENDING_USER_ACTION) {
            context.startActivity(intent.getParcelableExtra(Intent.EXTRA_INTENT));

            return;
        }

        int id = intent.getIntExtra(EXTRA_ID, 0);
        String statusMessage = intent.getStringExtra(PackageInstaller.EXTRA_STATUS_MESSAGE);
        int legacyStatus = intent.getIntExtra(PackageInstaller.EXTRA_LEGACY_STATUS, 0);

        EventResultObserver observerToCall = null;
        synchronized (mLock) {
            int numObservers = mObservers.size();
            for (int i = 0; i < numObservers; i++) {
                if (mObservers.keyAt(i) == id) {
                    observerToCall = mObservers.valueAt(i);
                    mObservers.removeAt(i);

                    break;
                }
            }

            if (observerToCall != null) {
                observerToCall.onResult(status, legacyStatus, statusMessage);
            } else {
                mResults.put(id, new EventResult(status, legacyStatus, statusMessage));
                writeState();
            }
        }
    }

```

这里的 ` observerToCall.onResult(status, legacyStatus, statusMessage);` 使用的是 InstallInstalling中的 launchFinishBasedOnResult 方法

```java
    private void launchFinishBasedOnResult(int statusCode, int legacyStatus, String statusMessage) {
        if (statusCode == PackageInstaller.STATUS_SUCCESS) {
            launchSuccess();
        } else {
            launchFailure(statusCode, legacyStatus, statusMessage);
        }
    }
```

即成功打开成功页面 InstallSuccess ，失败打开失败页面 InstallFailed。

## 七、PackageManagerService

PackageInstallerSession的中验证和安装实际上交给了PMS，我们来看看PMS中是如何处理的：

### 1. PMS 验证

```
void verifyStage(VerificationParams params) {
    mHandler.post(()-> {
        params.startCopy();
    });
}
final void startCopy() {
    if (DEBUG_INSTALL) Slog.i(TAG, "startCopy " + mUser + ": " + this);
       handleStartCopy();
       handleReturnCode();
}

```

#### 1.1 VerificationParams#handleStartCopy

```java

        public void handleStartCopy() {
            if ((installFlags & PackageManager.INSTALL_APEX) != 0) {
                mRet = INSTALL_SUCCEEDED;
                return;
            }
			//解析包，返回最小的细节，pkgName、versionCode、安装需要空间大小、安装未知等
            PackageInfoLite pkgLite = PackageManagerServiceUtils.getMinimalPackageInfo(mContext,
                    mPackageLite, origin.resolvedPath, installFlags, packageAbiOverride);
			//验证一下，验证失败返回错误码：如安装版本吗不匹配、不能降版本升级等
            mRet = verifyReplacingVersionCode(pkgLite, requiredInstalledVersionCode, installFlags);
            if (mRet != INSTALL_SUCCEEDED) {
                return;
            }
			//验证包完整性
            if (!origin.existing) {
                sendApkVerificationRequest(pkgLite);
                if ((installFlags & PackageManager.INSTALL_ENABLE_ROLLBACK) != 0) {
                    sendEnableRollbackRequest();
                }
            }
        }
```

#### 1.2 VerificationParams#handleReturnCode

```java
        void handleReturnCode() {
            if (mWaitForVerificationToComplete || mWaitForIntegrityVerificationToComplete
                    || mWaitForEnableRollbackToComplete) {
                return;
            }
            sendVerificationCompleteNotification();
        }

  		private void sendVerificationCompleteNotification() {
            //......
            observer.onPackageInstalled(null, mRet, "Package Verification Result",new Bundle()); 
            //......
        }

```

这里调用observer.onPackageInstalled方法，observer是从VerificationParams 的构造方法中传入的，之前我们已经知道了，当验证完成并成功后，会调用 PackageInstallSession # onVerificationComplete 方法，最终调用PMS的installStage方法

### 2.PMS 安装



```java
    void installStage(InstallParams params) {
        final Message msg = mHandler.obtainMessage(INIT_COPY);
        params.setTraceMethod("installStage").setTraceCookie(System.identityHashCode(params));
        msg.obj = params;
        mHandler.sendMessage(msg);
    }
```

这里通过handler发送消息 INIT_COPY, 消息的处理在PMS的内部类 PackageHandler 中：

```java
    class PackageHandler extends Handler {

        void doHandleMessage(Message msg) {
            switch (msg.what) {
                case INIT_COPY: {
                    HandlerParams params = (HandlerParams) msg.obj;
                    if (params != null) {
                        params.startCopy();
                    }
                    break;
                }
                //......
            }
        }
    }
```

最终还是调用InstallParams 的startCopy方法：

即按顺序调用 handleStartCopy、 handleReturnCode

#### 2.1 InstallParams#handleStartCopy

```java
       public void handleStartCopy() {
            if ((installFlags & PackageManager.INSTALL_APEX) != 0) {
                mRet = INSTALL_SUCCEEDED;
                return;
            }
           //解析包 返回最小的细节:pkgName、versionCode、安装所需空间大小
            PackageInfoLite pkgLite = PackageManagerServiceUtils.getMinimalPackageInfo(mContext,
                    mPackageLite, origin.resolvedPath, installFlags, packageAbiOverride);
			//检查一些失败情况
            mRet = overrideInstallLocation(pkgLite);
        }
```

#### 2.2 InstallParams#handleReturnCode

```java
     @Override
        void handleReturnCode() {
            processPendingInstall();
        }

        private void processPendingInstall() {
            InstallArgs args = createInstallArgs(this);
            if (mRet == PackageManager.INSTALL_SUCCEEDED) {
                mRet = args.copyApk();
            }
            if (mRet == PackageManager.INSTALL_SUCCEEDED) {
                F2fsUtils.releaseCompressedBlocks(
                        mContext.getContentResolver(), new File(args.getCodePath()));
            }
            if (mParentInstallParams != null) {
                mParentInstallParams.tryProcessInstallRequest(args, mRet);
            } else {
                PackageInstalledInfo res = createPackageInstalledInfo(mRet);
                processInstallRequestsAsync(
                        res.returnCode == PackageManager.INSTALL_SUCCEEDED,
                        Collections.singletonList(new InstallRequest(args, res)));
            }
        }

```



















































































































